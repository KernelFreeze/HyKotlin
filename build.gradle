buildscript {
    dependencies {
        def kotlinVersion = file("generated/kotlin_version.txt").text
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"


        classpath("org.apache.maven:maven-artifact:3.9.6")
    }
}

plugins {
    id 'maven-publish'
    id "com.diffplug.spotless" version "6.19.0"
    id "com.gradleup.shadow" version "9.0.0-beta11"
}

repositories {
    mavenCentral()
    mavenLocal()
    maven {
        name = 'eufoniaMavenReleases'
        url = "https://maven.eufonia.studio/releases/"
        credentials {
            username = System.getenv("EUFONIA_USERNAME")
            password = System.getenv("EUFONIA_PASSWORD")
        }
        authentication {
            basic(BasicAuthentication)
        }
    }
}

apply plugin: "org.jetbrains.kotlin.jvm"

group = project.group

def ENV = System.getenv()
def LIBRARY_VERSIONS_FILE = "generated/library_versions.json"
def KOTLIN_VERSION_FILE = "generated/kotlin_version.txt"

def kotlinLib = "org.jetbrains.kotlin:kotlin-stdlib"
def libraries = [
        kotlinLib,
        "org.jetbrains.kotlin:kotlin-stdlib-jdk8",
        "org.jetbrains.kotlin:kotlin-stdlib-jdk7",
        "org.jetbrains.kotlin:kotlin-reflect",

        "org.jetbrains.kotlinx:kotlinx-coroutines-core",
        "org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm",
        "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8",
        "org.jetbrains.kotlinx:kotlinx-serialization-core-jvm",
        "org.jetbrains.kotlinx:kotlinx-serialization-json-jvm",
        "org.jetbrains.kotlinx:kotlinx-serialization-cbor-jvm",
        "org.jetbrains.kotlinx:atomicfu-jvm",
        "org.jetbrains.kotlinx:kotlinx-datetime-jvm",
        "org.jetbrains.kotlinx:kotlinx-io-core-jvm",
        "org.jetbrains.kotlinx:kotlinx-io-bytestring-jvm"
]

def libVersions = new JsonSlurper().parse(file(LIBRARY_VERSIONS_FILE))
def hasMissingLibVersion = !libVersions.keySet().containsAll(libraries)
def kotlinVersion = file(KOTLIN_VERSION_FILE).text

println("Kotlin: ${kotlinVersion}")
println("Libraries:")
libVersions.forEach { k, v ->
    println("\t${k}:${v}")
}

version = "${project.pluginVersion}+kt${kotlinVersion.replaceAll('\\.', 'v')}" + (ENV.GITHUB_ACTIONS ? "" : "local")

configurations {
    shadow
}

configurations.all {
    resolutionStrategy {
        failOnNonReproducibleResolution()
    }
}

dependencies {
    implementation("com.hypixel:hytale-server:2026.01.13-50e69c385")

    if (hasMissingLibVersion) {
        println("Contains missing library version, run updateLibraryVersions task!")
    } else {
        libraries.forEach {
            def dep = "${it}:${libVersions[it]}"
            implementation(dep)
            shadow(dep)
        }
    }
}

processResources {
    inputs.property "version", project.version

    filesMatching("manifest.json") {
        expand "version": project.version
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.release = 8
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

java {
    withSourcesJar()
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

spotless {
    kotlin {
        licenseHeaderFile(rootProject.file("HEADER"))
    }
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.base.archivesName.get()}" }
    }
}

shadowJar {
    configurations = [project.configurations.shadow]
    archiveClassifier.set("")
}

build.dependsOn shadowJar

test {
	useJUnitPlatform()
}

task processMDTemplates(type: Copy) {
    group = "documentation"
    doFirst {
        if (hasMissingLibVersion) {
            throw new GradleException("Contains missing library version, run updateLibraryVersions task first!")
        }
    }

    from(file("templates"))
    include("**/*.template.md")
    filesMatching("**/*.template.md") {
        name = sourceName.replace("template.", "")
        def template = [
                PLUGIN_VERSION   : "${project.pluginVersion}+kt${kotlinVersion.replaceAll('\\.', 'v')}",
                KOTLIN_VERSION   : "${kotlinVersion}",
        ]
        libraries.forEach {
            def key = it.split(":", 2)[1].replace("-", "_").toUpperCase(Locale.ROOT) + "_VERSION"
            template.put(key, libVersions[it])
        }
        expand(template)
    }
    destinationDir = rootDir
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId = project.group
            artifactId = project.name.toLowerCase()
            version = project.version

            from components.java
        }
    }

    repositories {
        maven {
            name = "GitHubPackages"
            url = uri("https://maven.pkg.github.com/KernelFreeze/HyKotlin")
            credentials {
                username = project.findProperty("gpr.user") ?: System.getenv("USERNAME")
                password = project.findProperty("gpr.key") ?: System.getenv("TOKEN")
            }
        }
        maven {
            name = 'eufoniaMavenPublic'
            url = "https://maven.eufonia.studio/public/"
            credentials {
                username = System.getenv("EUFONIA_USERNAME")
                password = System.getenv("EUFONIA_PASSWORD")
            }
            authentication {
                basic(BasicAuthentication)
            }
        }
    }
}

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import org.apache.maven.artifact.versioning.ComparableVersion

import java.nio.charset.StandardCharsets

static def getBranch() {
    def ENV = System.getenv()
    if (ENV.GITHUB_REF) {
        def branch = ENV.GITHUB_REF
        return branch.substring(branch.lastIndexOf("/") + 1)
    }

    throw new RuntimeException("Unable to get branch")
}

task updateLibraryVersions {
    group = "update"
    doFirst {
        def output = [:]
        def slurper = new XmlSlurper()
        for (def lib : libraries) {
            def split = lib.split(":", 2)
            def group = split[0].replace(".", "/")
            def artifact = split[1]
            def xml = new URL("https://repo1.maven.org/maven2/${group}/${artifact}/maven-metadata.xml").text
            def metadata = slurper.parseText(xml)
            def versions = metadata.versioning.versions.version*.text()

            def latest = versions[0]
            def latestParsed = ComparableVersion(latest)
            for (def version : versions) {
                def parsed = ComparableVersion(version)
                if (parsed.qualifier == null && parsed > latestParsed) {
                    latestParsed = parsed
                    latest = version
                }
            }

            println("${lib} = ${latest}")
            output.put(lib, latest)

            if (lib == kotlinLib) {
                file(KOTLIN_VERSION_FILE).setText(latest, StandardCharsets.UTF_8.name())
            }
        }
        def json = new JsonBuilder(output)
        file(LIBRARY_VERSIONS_FILE).setText(json.toPrettyString(), StandardCharsets.UTF_8.name())
    }
}

task updateVersions {
    group = "update"
    dependsOn(updateLibraryVersions)
}

